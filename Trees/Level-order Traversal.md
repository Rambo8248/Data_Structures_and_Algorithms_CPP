## Level-order Traversal

In levelorder traversal, we visit all nodes at a particular depth or level before visiting the nodes at next deeper level. We must visit the nodes from level-0 to the end-level from left to right consequently. But the question is, how can we visit the nodes in this order in a program. Like linked list, we can't just have one pointer and keep moving it. If we start with a pointer at root, lets say we have a pointer named current to point to the current node that we are visiting, then its possible for us to go from root to left child using this pointer because there is a link. So we can go left from root. but from that position we cannot go to the right child to root, because there is no link from child to parent. The only way we can go to right child is from parent, but once we have moved to pointer to parent's left child we cannot even go back to parent. So, what can we do to traverse the nodes in level order? Clearly, we cannot go with just one pointer. What we can do is, as we visit a node, we can keep reference or address of all its children in a *queue*, so we can visit them later. A node in the queue can be called discovered node whose address is known to us, but we have not visited it yet. Initially, we can start with address of root node in the queue to mean that initially this is the only discovered node. By storing the node in the queue we will mean storing the address of the node in the queue. As long as the queue has one discovered note (as long as the queue is not empty), we can take out a node from front, visit it and then enqueue its children. By using a queue, we are doing 2 things here. First of all, as we are moving from a node, we are not loosing reference to its children, because we are storing the references and then because queue is a first in first out (*FIFO*) structure, so a node that is discovered first, that is inserted first will be visited first. So, we will get this order that we are desiring. 

![](https://i.postimg.cc/jjPBB0HK/asd.png)

Once the queue is empty we are done with the traversal. In tha epproach, at any time, we are keeping a bunch of addresses in the memory (in the queue) instead of using just one pointer to move around. So, of course we are using a lot of extra memory. 

[Here you can see the code implemented in C++ for level order traversal](https://github.com/andy489/Data_Structures_and_Algorithms_CPP/blob/master/Level-order%20Traversal%20in%20BT.cpp)

Lets now talk about time and space complexity of level order traversal. If there are *n* nodes  in the tree and in this algorithm, visit to a node is reading the data in that node and inserting its children in the queue, then a visit to a node will take constant time and each node will be visited exactly once. So, time taken will be proportional to the number of nodes. Or in other words, we can say that the time complexity is O(n). For all cases, irrespective of the shape of the tree, time complexity of level order traversal will be O(n). Now lets talk about space complexity. Space complexity, as we know is the measure of rate of growth of extra memory used with input size. We are not using constant amount of extra memory in this algorithm. We have this queue that will grow and shrink while executing this algorithm. Assuming that the queue is dynamic, maximum amount of extra memory used will depend upon maximum elements in the queue at any time. We can have couple of cases. In some cases, extra memory used will be lesser and in some cases, etra memory used will be greater. For a tree for which each node has only one child, we will have maximum one element in the queue at any time. During each visit, one node will be taken out from the queue and one node will be inserted. So, the amount of extra memory taken will not depend upon the number of nodes. Space complexity will be O(1). But for a perfect binary tree (all levels are full), the amount of extra memory used will depend upon number of nodes in the tree. If we can see, as the algorithm will execute, at some point for each level, all the nodes in that level will be in the queue. In a perfect binary tree, we will have n/2 nodes at the deepest level. So, maximum number of nodes in the queue is going to be at least n/2. So, basically extra memory used is proportional to *n* - the number of nodes. So, space complexity will be O(n) for this case.

- Time-complexity
  - O(n)-all cases
- Space-complexity
 - O(1)-best
 - O(n)-worst/average

