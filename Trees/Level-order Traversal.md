## Level-order Traversal

In levelorder traversal, we visit all nodes at a particular depth or level before visiting the nodes at next deeper level. We must visit the nodes from level-0 to the end-level from left to right consequently. But the question is, how can we visit the nodes in this order in a program. Like linked list, we can't just have one pointer and keep moving it. If we start with a pointer at root, lets say we have a pointer named current to point to the current node that we are visiting, then its possible for us to go from root to left child using this pointer because there is a link. So we can go left from root. but from that position we cannot go to the right child to root, because there is no link from child to parent. The only way we can go to right child is from parent, but once we have moved to pointer to parent's left child we cannot even go back to parent. So, what can we do to traverse the nodes in level order? Clearly, we cannot go with just one pointer. What we can do is, as we visit a node, we can keep reference or address of all its children in a *queue*, so we can visit them later. A node in the queue can be called discovered node whose address is known to us, but we have not visited it yet. Initially, we can start with address of root node in the queue to mean that initially this is the only discovered node. By storing the node in the queue we will mean storing the address of the node in the queue. As long as the queue has one discovered note (as long as the queue is not empty), we can take out a node from front, visit it and then enqueue its children. By using a queue, we are doing 2 things here. First of all, as we are moving from a node, we are not loosing reference to its children, because we are storing the references and then because queue is a first in first out (*FIFO*) structure, so a node that is discovered first, that is inserted first will be visited first. So, we will get this order that we are desiring. 

![](https://i.postimg.cc/jjPBB0HK/asd.png)

Once the queue is empty we are done with the traversal. In tha epproach, at any time, we are keeping a bunch of addresses in the memory (in the queue) instead of using just one pointer to move around. So, of course we are using a lot of extra memory. 


