## Adjacency Matrix Representation

We realised that storing a graph in an *Edge List Representation* is not very efficient in terms of time cost of most frequently performed operations like **finding nodes adjacent to a given node** or **finding if two nodes are connected or not**. To perform any of these operations, we need to scan the whole edge list. We need to perform a linear search on the edge list. So the time complexity is <img src="https://latex.codecogs.com/svg.latex?\Large&space;O\(|{E}|)"> and we know that number of edges in a graph can be really large. In worst case it can be close to square of number of vertices. In a graph, anything running in order of number of edges is considered very costly. We often want to keep the cost in order of number of vertices. So we should think of some other efficient design.

One more possible design is that we can store the edges in a two-dimensional array or matrix. We can have a two-dimensional matrix or array of size <img src="https://latex.codecogs.com/svg.latex?\Large&space;v*v">, where *v* is number of vertices.

![](https://i.ibb.co/Nxw8rSH/ga1.png)

Let's name this 2D array *A*. Now if we want to store a graph that is unweighted and if we have a value or index between *0* and *V-1* for each vertex, which we have in the above example (*if we are storing the vertices in a vertex list, then we have an index between 0 and V-1 for each vertex*). We can say that *A* is zeroth node, *B* is 1th node, *C* is 2th node and so on. We are picking up indeces from the vertex list. If the graph is unweighted and each vertex has an index between *0* and *V-1*, then in the matrix or 2D array we can set *i-th* row and *j-th* column that is *A[i][j]* as *1* or boolean value *true*, if there is an edge from *i* to *j* and *0* or *false* otherwise.

<img src="https://latex.codecogs.com/svg.latex?\Large&space;A_{ij}=\begin{cases}1,{\;}if{\quad}{\exists}{\;}edge{\;}from{\;}i{\;}to{\;}j\\0,{\;}{otherwise}\end{cases}">

If we have to fill this matrix for the example graph, then we will go vertex by vertex. Vertex 0 is connected to vertex 1, 2 and 3. Vertex 1 is connected to 0, 4 and 5. (*This is an undirected graph so if we have an edge from 0 to 1, we also have an edge from 1 to 0, so 1th row and 0th column should also be set as 1.*) We continue to row 2: vertex 2 is connected to vertex 0 and 6. 3 is connected to 0 and 7 and etc. and we fill those positions with ones. All the remaining positions int the array should be set as 0.

![](https://i.ibb.co/4V9hcFW/ga2.png)

Notice that this matrix is symetric. For an undirected graph, this matrix would be symmetric because A[i][j] would be equal to A[j][i]. We would have two positions filled for each edge. In fact to see all the edges in the graph, e need to go through only one of the two halves - over and under the main diagonal of the matrix (*This would not be true for a directed graph. Only one position will be filled for each edge and we will have to go through the entire matrix to see all the edges*). Now this kind of representation of a graph in which edges or connections are stored in a matrix or 2D array is called *adjacency matrix representation*. This particular matrix that we have drawn above is an adjacency matrix. *Now, with this kind of storage or representation, what do you think would be the time cost of finding all nodes adjecent to a given node?*

Let's say that is given the above vertex list and adjacency matrix and we want to find all nodes adjacent to node named *F*. If we are given name of a node, then we first need to know it's index and to know the index, we will have to scan the vertex list (there is no other way). Once we figured out the index like for *F* index is 5, then we can go to the row with that index in the adjacency matrix and we can scan the complete row to find all the adjacent nodes. Scanning the vertex list to figure out the index in worst case will cost us time proportional to the number of vertices, because in worst case we may have to scan the whole list. And scanning a row in the adjacency matrix would once again cost us time proportional to umber of vertices, because in a tow we would have exactly *v* columns, where *v* is number of vertices. So overall time cost of this operation is O(v). Most of the time while performing operations we must pass indices to avoid scanning the vertex list all the time. If we know an index, we can figure out the name in constant time, because in an array we can access element at any index in constant time but if we know a name and want to figure out the index, then it will cost us O(v) - we will have to scan the vertex list (or in other words to perform a linear search in it). 

*What would be the time cost of finding if 2 nodes are connected or not?* Once again the two nodes can be given to us as indeces or names. If the nodes would be passed as indeces, then we simply need to look at value in a particular row and particular column. We simply need to look at A[i][j] for some values of *i* and *j* and this will cost us constant time. You can look at value in any cell in a two-dimensional array in constant time. So if indices are given time complexity of this operation would be O(1), which simply means that we will take constant time but if names are given then we also need to do the scanning to figure out the indices which will cost us O(v). Overall time complexity would be O(v). The constant time access would not mean anything. The scanning of vertex list all the time to figure out the indeces can be avoided. We can use some extra memory to create **a hash table** with names and indices as *key value pairs* and then the time cost of finding index from name would also be O(1) that is constant. <br> So, with adjacency matrix representation our time cost of some of the most frequently performed operations is in order of number of vertices and not in order of number of edges which can be as high as square of number of vertices.

Now, if we want to store a weighted graph in adjacency matrix representation then A[i][j] in the matrix can be set as weight of an edge. For non-existent edges we can have a default value like a really large or maximum possible integer value that is never expected to be an edge weight. 

![](https://i.ibb.co/hs8xM0G/ga3.png)

We have filled infinity here and by that we mean that there is no such possible weight therefore there is no such edge. We can choose the default as infinity, minus infinity or any other value that would never ever be a valid edge weight. 

Now, for further discussion we are coming back to an unweighted graph.

![](https://i.ibb.co/4V9hcFW/ga2.png)

Adjecency matrix looks really good so should we not use it always? Well, with this design we have improved on time, but we have gone really high on memory usage. Instead of using memory units exactly equal to the number of edges - what we are doing with an edge list kind of storage, here we are using exactly <img src="https://latex.codecogs.com/svg.latex?\Large&space;O(v^2)">. We are not just storing the information that these two nodes are connected, we are also storing not of it - that is these two nodes are not connected , which probably is redundant information. If a graph is *dense*, if the number of edges is really close to <img src="https://latex.codecogs.com/svg.latex?\Large&space;v^2"> then this is good, but if the graph is *sparse* - that is if number of edges is lot lesser than <img src="https://latex.codecogs.com/svg.latex?\Large&space;v^2">, then we are wasting a lot of memory in storing these zeros. Like for the above example graph, in the edge list we were consuming 10 units of memory, we had ten rows consumed in the edge list, but here we are consuming 64 units. Most graphs with really large number of vertices would not be verey dense, would not have number of edges anywhere close to <img src="https://latex.codecogs.com/svg.latex?\Large&space;v^2">. Like for example, let's say we are modeling a social network like Facebook as a graph such that a user in the network is a node and there is an undirected edge if two users are friends.

![](https://i.ibb.co/yV74nr6/ga4.png)

Facebook has a billion users but we are showing only a few in our example graph, because we are short of space. Let's just assume that we have a billion users in our network. So number of vertices in a graph is <img src="https://latex.codecogs.com/svg.latex?\Large&space;|V|=v=10^9"> which is a billion. Now, do you think number of connections in our social network can ever be close to square number of users? (*Do you think we can ever have close to <img src="https://latex.codecogs.com/svg.latex?\Large&space;10^{18}"> connections in this graph?*). That will mean everyone in the network is a frined of everyone else. A user of our social network will not be a friend to all other billion users. We can safely assume that a user on an average would not have more than a thousand friends. With this assumption we would have <img src="https://latex.codecogs.com/svg.latex?\Large&space;|E|=10^9*10^3=10^{12}"> edges in our graph. Actually, this is an undirected graph so we should do a divide by 2 here, i.e. <img src="https://latex.codecogs.com/svg.latex?\Large&space;|E|=\frac{10^9*10^3}{2}=\frac{10^{12}}{2}=5*10^{11}">, so that we do not count an edge twice. So if average number of friends is 1000 then total number of connections in our graph is <img src="https://latex.codecogs.com/svg.latex?\Large&space;5*10^{11}">. Now this a lot lesser than a square of number of vertices. So basically if we would use an adjacency matrix for this kind of a graph, we would waste a hell lot of space and moreover even if we are not looking in relative terms 10 to the power of 18 units of memory, even in absolute sense is a lot. <img src="https://latex.codecogs.com/svg.latex?\Large&space;10^{18}{\;}bytes\thickapprox{1000}{\:}PB">(*PB - petabytes*), now this really is a lot of space. This much data would never ever fit on one physical disk.On the other hans <img src="https://latex.codecogs.com/svg.latex?\Large&space;5*10^{11}{\;}bytes\thickapprox{0.5}{\:}TB">, that is just 0.5 terabytes. A typical personal computer these days would have this much of storage. So as you can see for something like a large social graph - adjecency matrix representation is not very efficient. Adjecency matrix is good when a graph is dense - that is when the number of edges is close to square of number of vertices or sometimes when total number of possible connections that is <img src="https://latex.codecogs.com/svg.latex?\Large&space;v^2"> is so less that wasted space would not even matter. But most real-world graphs would be sparse and adjecency matrix would not be a good fit.

Let's think about another example.
