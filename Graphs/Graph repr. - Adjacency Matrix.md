## Adjacency Matrix Representation

We realised that storing a graph in an *Edge List Representation* is not very efficient in terms of time cost of most frequently performed operations like **finding nodes adjacent to a given node** or **finding if two nodes are connected or not**. To perform any of these operations, we need to scan the whole edge list. We need to perform a linear search on the edge list. So the time complexity is <img src="https://latex.codecogs.com/svg.latex?\Large&space;O\(|{E}|)"> and we know that number of edges in a graph can be really large. In worst case it can be close to square of number of vertices. In a graph, anything running in order of number of edges is considered very costly. We often want to keep the cost in order of number of vertices. So we should think of some other efficient design.

One more possible design is that we can store the edges in a two-dimensional array or matrix. We can have a two-dimensional matrix or array of size <img src="https://latex.codecogs.com/svg.latex?\Large&space;v*v">, where *v* is number of vertices.

![](https://i.ibb.co/Nxw8rSH/ga1.png)

Let's name this 2D array *A*. Now if we want to store a graph that is unweighted and if we have a value or index between *0* and *V-1* for each vertex, which we have in the above example (*if we are storing the vertices in a vertex list, then we have an index between 0 and V-1 for each vertex*). We can say that *A* is zeroth node, *B* is 1th node, *C* is 2th node and so on. We are picking up indeces from the vertex list. If the graph is unweighted and each vertex has an index between *0* and *V-1*, then in the matrix or 2D array we can set *i-th* row and *j-th* column that is *A[i][j]* as *1* or boolean value *true*, if there is an edge from *i* to *j* and *0* or *false* otherwise.

<img src="https://latex.codecogs.com/svg.latex?\Large&space;A_{ij}=\begin{cases}1,{\;}if{\quad}{\exists}{\;}edge{\;}from{\;}i{\;}to{\;}j\\0,{\;}{otherwise}\end{cases}">

If we have to fill this matrix for the example graph, then we will go vertex by vertex. Vertex 0 is connected to vertex 1, 2 and 3. Vertex 1 is connected to 0, 4 and 5. (*This is an undirected graph so if we have an edge from 0 to 1, we also have an edge from 1 to 0, so 1th row and 0th column should also be set as 1.*) We continue to row 2: vertex 2 is connected to vertex 0 and 6. 3 is connected to 0 and 7 and etc. and we fill those positions with ones. All the remaining positions int the array should be set as 0.

![](https://i.ibb.co/wLhgqFr/ga2.png)

Notice that this matrix is symetric. For an undirected graph, this matrix would be symmetric because A[i][j] would be equal to A[j][i]. We would have two positions filled for each edge. In fact to see all the edges in the graph, e need to go through only one of the two halves - over and under the main diagonal of the matrix (*This would not be true for a directed graph. Only one position will be filled for each edge and we will have to go through the entire matrix to see all the edges*). Now this kind of representation of a graph in which edges or connections are stored in a matrix or 2D array is called *adjacency matrix representation*. This particular matrix that we have drawn above is an adjacency matrix. *Now, with this kind of storage or representation, what do you think would be the time cost of finding all nodes adjecent to a given node?*

Let's say that is given the above vertex list and adjacency matrix and we want to find all nodes adjacent to node named *F*. If we are given name of a node, then we first need to know it's index and to know the index, we will have to scan the vertex list (there is no other way). Once we figured out the index like for *F* index is 5, then we can go to the row with that index in the adjacency matrix and we can scan the complete row to find all the adjacent nodes. Scanning the vertex list to figure out the index in worst case will cost us time proportional to the number of vertices, because in worst case we may have to scan the whole list. And scanning a row in the adjacency matrix would once again cost us time proportional to umber of vertices, because in a tow we would have exactly *v* columns, where *v* is number of vertices. So overall time cost of this operation is O(v). Most of the time while performing operations we must pass indices to avoid scanning the vertex list all the time. If we know an index, we can figure out the name in constant time, because in an array we can access element at any index in constant time but if we know a name and want to figure out the index, then it will cost us O(v) - we will have to scan the vertex list (or in other words to perform a linear search in it). 

*What would be the time cost of finding if 2 nodes are connected or not?* Once again the two nodes can be given to us as indeces or names. If the nodes would be passed as indeces, then we simply need to look at value in a particular row and particular column. We simply need to look at A[i][j] for some values of *i* and *j* and this will cost us constant time. You can look at value in any cell in a two-dimensional array in constant time. So if indices are given time complexity of this operation would be O(1), which simply means that we will take constant time but if names are given then we also need to do the scanning to figure out the indices which will cost us O(v). Overall time complexity would be O(v). The constant time access would not mean anything. The scanning of vertex list all the time to figure out the indeces can be avoided. We can use some extra memory to create **a hash table** with names and indices as *key value pairs* and then the time cost of finding index from name would also be O(1) that is constant. <br> So, with adjacency matrix representation our time cost of some of the most frequently performed operations is in order of number of vertices and not in order of number of edges which can be as high as square of number of vertices.

Now, if we want to store a weighted graph in adjacency matrix representation then A[i][j] in the matrix can be set as weight of an edge. For non-existent edges we can have a default value like a really large or maximum possible integer value that is never expected to be an edge weight. 

![](https://i.ibb.co/hs8xM0G/ga3.png)

