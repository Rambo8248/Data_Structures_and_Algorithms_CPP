# Searching Algorithms

Aлгоритъмът за търсене е алгоритъм за намиране на елемент със специфични свойства сред колекция от елементи.

Име | метод 
------- | ------- 
**Linear Search** *Последователно търсене* |  обхожда елемент по елемент (изходен елемент за оптимизация)
*Последователно търсене в сортиран списък* |  обхожда елемент по елемент, до достигане на такъв с по-голям ключ
*Последователно търсене с преподреждане* |  обхожда елемент по елемент и актоализира позицията на всеки търсен елемент 
**Quadratic Search** *Търсене със стъпка/Kвадратично търсене*  |  обхожда сектор по сектор в сортиран списък

### 1. Последователно търсене
Най-елементарният и очевиден алгоритъм за търсене е последователното търсене. Нека предположим, че елементите на множеството се съдържат в едномерен масив. Търсенето се извършва посредством последователно преглеждане на елементите на масива до откриване на търсения елемент или до преглеждане на всички елементи. Последното означава, че елемент с такъв ключ не съществува.При постъпване на нов елемент ще го вмъкваме в края на масива *seqSearch()*. Следва една възможна реализация на основните функции, основаваща се на последователното търсене:

```cpp
#define MAX 10
#define DataType int
#include <iostream>
#include <time.h>

struct CPPElem
{
	int key;
	DataType data;
	/*...*/
}m[MAX + 1]; /* Масив от записи*/
unsigned n;  /*Брой елементи в масива*/

void seqInit(void) { n = 0; }  /*Инициализиране*/

unsigned seqSearch(int key)    /*Последователно търсене*/
{
	unsigned x;
	m[0].key = key;  /*Ограничител*/
	for (x = n + 1; key != m[--x].key; );
	return x;
}

void seqInsert(int key, DataType data) /*Добавя нов елемент*/
{
	m[++n].key = key;
	m[n].data = data;
}

void seqPrint(void) /*Извежда списъка на екрана*/
{
	unsigned i;

	for (i = 1; i <= n; i++)
	{
		std::cout << m[i].key << ' ' << m[i].data << std::endl;
	}
}

void performSearchTest(void)
{
	unsigned ind, elem2Search;
	for (elem2Search = 0; elem2Search < 2 * MAX; elem2Search++)
	{
		std::cout << "We search an element with key " << elem2Search << "\n";
		if (0 == (ind = seqSearch(elem2Search)))
			std::cout << "Element with such key does not exist!" << "\n\n";
		else
			std::cout << "Item found! Info part: " << m[ind].data << "\n\n";
	}
}

int main()
{
	srand(unsigned(time(0)));
	unsigned ind;
	seqInit();
	for (ind = 0; ind < MAX; ind++) seqInsert(rand() % (MAX * 2), ind);
	std::cout << "the list contains the following items:\n";
	seqPrint();
	std::cout << "Testing:\n";
	performSearchTest();
	return 0;
}
```
По-горе сме приели, че същинската информационна част на елементите на масива съдържа единствено поле *data*. Както се забелязва, търсенето се извършва последователно по посока на намаляване на индексите. Забележете, че нулевия елемент на масива не съдържа елемент на множеството, а служебна информация. Той е използван като *елемент-ограничител*, позволяващ опростяване на цикъла: проверява се само едно условие, тъй като сме осигурили намирането на елемент със зададения ключ (в краен случай нулевият). В случай на дублиране на ключове горният алгоритъм очевидно връща последния постъпил елемент с този ключ. 

Каква е сложността на алгоритъма в средния и в най-лошия случай съответно? Ясно е, че най-лошият случай е когато търсеният елемент липсва. Тогава се преглеждат всичките *n+1* елемента на масива, включително нулевият. В общия случай, когато търсенето е успешно, средният брой на извършените сравнения е <img src="https://latex.codecogs.com/svg.latex?\Large&space;\frac{n+1}{2}">. Същевременно, за намиране на всички елементи с даден ключ е необходимо *цялостно* преглеждане на масива.

#### 1.1. Последователно търсене в сортиран списък:

Последователното търсене, разгледано по-горе, е най-простият и най-неефективният алгоритъм за търсене. Бихме могли да се опитаме да подобрим ефективността му, поддържайки елементите в сортиран вид. Това ще ни се удаде сравнително лесно, ако използваме свързан списък вместо масив. Всичко което трябва да направим, е да вмъкваме всеки новопостъпил елемент на съответното му място, така че списъкът да остава сортиран. Така преди всяко вмъкване ще се изисква извършване на съответно търсене, за да се открие съответната позиция.

Операцията по вмъкване се усложнява значително. По-горе я извършвахме за константно време, без нито едно сравнение, а сега това ще изисква предварително търсене. Какво все пак постигнахме? Обстоятелството, че елементите са подредени в нарастващ ред, ще ни позволи да прекратяваме по-нанатъшното търсене при достигане на елемент с ключ, по-голям от търсения. Броят на необходимите сравнения в случай на неуспешно търсене намалява до <img src="https://latex.codecogs.com/svg.latex?\Large&space;\frac{n+1}{2}">, в сравнение с <img src="https://latex.codecogs.com/svg.latex?\Large&space;n+1"> при несортирания случай. На практика успешното и неуспешното търсене се оказват равнопоставени, тъй като тази модификация очевидно не влияе на успешното търсене. В най-лошия случай отново трябва да се прегледат всички елементи, т.е. да се извършат <img src="https://latex.codecogs.com/svg.latex?\Large&space;n+1"> сравнения. Оказва се, че в замяна на това, че сме приравнили сложността на вмъкването, която по-рано беше константна, към сложността на търсенето, получаваме само равнопоставеност на успешно и неуспешно търсене. Полученият реултат е изключително поучителен и показва, че преди да се пристъпи към някаква „очевидна“ оптимизация, следва много внимателно да се прецени възможната полза и вреда, които тя ще принесе.

Следва примерна реализация на последователно търсене в сортиран списък, заедно със съответна версия на функции за вмъкване и инициализиране:

```cpp
#define DataType int
#define MAX 10
#include <iostream>
#include <time.h>

struct CPPElem
{
	int key;
	DataType data;
	struct CPPElem *next;
	/* ... */
} *head;

void listInit(void) /* Инициализиране */
{
	head = (struct CPPElem*) malloc(sizeof *head);
	head->next = nullptr;
}

void listInsert(int key, DataType data)/* Добавя нов елемент */
{
	struct CPPElem *p, *q, *r;
	q = (struct CPPElem*) malloc(sizeof *head);
	r = (p = head)->next;
	while (r != nullptr && r->key < key)
	{
		p = r;
		r = r->next;
	}
	q->key = key;
	q->data = data;
	q->next = r;
	p->next = q;
}
struct CPPElem *listSearch(int key) /* Последователно търсене */
{
	struct CPPElem *q;
	for (q = head->next; q != nullptr&&q->key < key; q = q->next);
	if (nullptr == q || key != q->key)
		return nullptr;
	else
		return q;

}

void listPrint(void) /* Извежда списъка на екрана */
{
	struct CPPElem *q;
	for (q = head->next; q != nullptr; q = q->next)
	{
		std::cout << q->key << ' ' << q->data;
		std::cout << std::endl;
	}
}

int main()
{
	srand(unsigned(time(0)));
	unsigned ind;
	listInit();
	for (ind = 0; ind < MAX; ind++) listInsert(rand() % (MAX * 2), ind);
	std::cout << "the list contains the following items:\n";
	listPrint();

	std::cout << "Serching: \n";
	CPPElem *el = listSearch(10);
	if (el) std::cout << "Element found: key " << el->key << "; data " << el->data << '\n';
	else std::cout << "No element with such key found.\n";

	return 0;
}
```
#### 1.2. Последователно търсене с преподреждане:

В случай, че разполагаме с предварителна информация относно вероятността за достъп до всеки от елементите, бихме могли да ги подредим така, че най-често търсеният да бъде на върха на списъка, следващият - непосредствено след него и т.н. Използването на подобна стратегия се оказва изключително ефективно, особено при силно неравномерно разпределение, при което малък брой елементи се търсят с много голяма ефективност.

В случай, че не разполагаме с такава предварителна информация, бихме могли сами да си я получим с помощта на прости статистически наблюдения: достатъчно е към всеки елемент да прикрепим брояч на достъпа до него. При всяко ново търсене ще актуализираме брояча на търсения елемент. Ясно е, че след актуализацията той евентуално ще може да мине по-напред в списъка. Ето защо следва да се направи сравнение с предходния елемент в списъка, при което евентуално двата да се разменят. Тъй като в списъка може да има многократно дублиране на честотите на достъп, в случай на размяна се налага съответно сравнение и със следващия предходен елемент и т.н. до достигане на точната позиция, съответваща на новата честота на елемента. Реорганизацията става за време, пропорционално на <img src="https://latex.codecogs.com/svg.latex?\Large&space;n">, като в най-лошия случай може да се случи последният елемент на списъка да стане първи, разменяйки се последователно с всички преди него [*Уирт-1980*].

Предложената по-горе схема с поддържане на специални броячи обаче се оказва тромава, изисква допълнителна памет от порядъка на <img src="https://latex.codecogs.com/svg.latex?\Large&space;n"> и би могла да се оптимизира. За пореден път се оказва, че простото е по-добро. Действително, в този случай се оказва изключително ефективно прилагането на по-проста стратегия за реорганизация. Не се поддържат никакви броячи и не се води никаква статистика. Вместо това, при всяко успешно търсене на елемент той се поставя в началото на списъка. Разбира се тази стратегия не ни гарантира оптимално подреждане на елементите съгласно честотата им на достъп, но пък е лесна за поддържане и достатъчно ефективна. Действително, за разлика от варианта с броячите, тук реорганизацията става за време константа. От друга страна, колкото по-често е осъществяван достъп до даден елемент, с толкова по-голяма вероятност той ще се намира сред първите елементи на списъка. При това така по-добре се отчитат локалните особености: ако някой глобално погледнато рядко търсен елемент в даден момент се търси често, тази стратегия ще ни позвили да се възползваме от това.

```cpp
#define DataType int
#define MAX 10
#include <iostream>
#include <time.h>

struct CPPElem
{
	int key;
	DataType data;
	struct CPPElem *next;
	/* ... */
} *head;

void listInit(void) /* Инициализиране */
{
	head = (struct CPPElem*) malloc(sizeof *head);
	head->next = nullptr;
}

void listInsert(int key, DataType data)/* Добавя нов елемент */
{
	struct CPPElem *q = (struct CPPElem*) malloc(sizeof *head);
	q->key = key; q->data = data;
	q->next = head; head = q;
}
struct CPPElem *listSearch(int key) /* Последователно търсене с преподреждане */
{
	struct CPPElem *q, *p = head;
	if (nullptr == head)
		return nullptr;
	if (head->key == key) return head;
	for (q = head->next; q != nullptr; )
	{
		if (q->key != key)
		{
			p = q;
			q = q->next;
		}
		else
		{
			p->next = q->next;
			q->next = head;
			return (head = q);
		}
	}
	return nullptr;
}

void listPrint(void) /* Извежда списъка на екрана */
{
	struct CPPElem *q;
	for (q = head; q->next != nullptr; q = q->next)
	{
		std::cout << q->key << ' ' << q->data;
		std::cout << std::endl;
	}
}

int main()
{
	srand(unsigned(time(0)));
	unsigned ind;
	listInit();
	for (ind = 0; ind < MAX; ind++) listInsert(rand() % (MAX * 2), ind);
	std::cout << "the list contains the following items:\n";
	listPrint();

	std::cout << "Serching: \n";
	CPPElem *el = listSearch(10);
	if (el) std::cout << "Element found: key " << el->key << "; data " << el->data << '\n';
	else std::cout << "No element with such key found.\n";
	listPrint();
	return 0;
}
```

### 2. Търсене със стъпка. Квадратично търсене (Qadratic search)

Нека отново разгледаме случая на наредено множество. Разгледаният по-горе метод на търсене в сортиран списък се отличаваше незначително от стандартното последователно търсене и не използваше достатъчно пълноценно наредбата на елементите. Ще се опитаме да поправим тази грешка, като за целта ще възприемем коренно различен подход. Нека изберем някаква стъпка <img src="https://latex.codecogs.com/svg.latex?\Large&space;k"> и последователно извършваме проверката дали ключът на търсения елемент е по-голям от първия елемент, от <img src="https://latex.codecogs.com/svg.latex?\Large&space;k+1">-ия елемент, от <img src="https://latex.codecogs.com/svg.latex?\Large&space;2k+1">-ия елемент, от <img src="https://latex.codecogs.com/svg.latex?\Large&space;3k+1">-ия елемент, ... Т.е. сравняваме го с <img src="https://latex.codecogs.com/svg.latex?\Large&space;m[1].key,m[k+1].key,m[2*k+1].key,...">. Процесът приключва при достигане на елемент, по-голям или равен на <img src="https://latex.codecogs.com/svg.latex?\Large&space;x">, или на края на масива.

Да разгледаме по-внимателно горната схема (ще я наричаме *търсене със стъпка*). Нека предположим, че, прилагайки я, сме достигнали до елемент, по-голям от <img src="https://latex.codecogs.com/svg.latex?\Large&space;x">. Сега можем да използваме последователно търсене в интервала, определен от последните две проби. В случай, че сме били излезли извън масива, можем да използваме последователно търсене от предишната проба до края на масива. Очевидно подобен подход би могъл да доведе до силно съкращаване на броя на елементите, които се преглеждат от последователното търсене. Освен това лесно се вижда, че използвания метод е обобщение на линейното търсене. Действително, последното се получава при <img src="https://latex.codecogs.com/svg.latex?\Large&space;k=1">.

Съгласно приведеното по-горе описание, предложеният метод винаги започва с <img src="https://latex.codecogs.com/svg.latex?\Large&space;m[1].key">. Доколко подобно начало е удачно? Не е трудно да се види, че това всъщност е лош избор, при това по същите причини, по които е лош изборът <img src="https://latex.codecogs.com/svg.latex?\Large&space;m[n].key">: носи минимално количество информация. Оказва се, че е много по удачно да се започне направо с <img src="https://latex.codecogs.com/svg.latex?\Large&space;m[k].key">. Лесно се вижда, че и в този случай при <img src="https://latex.codecogs.com/svg.latex?\Large&space;k=1"> се получава линейно търсене.

Каква е ефективността на описания метод при фиксирано <img src="https://latex.codecogs.com/svg.latex?\Large&space;k"> и кой е най-лошия случай? Ясно е, че линейното търсене има еднаква цена за всички инервали от вида <img src="https://latex.codecogs.com/svg.latex?\Large&space;\big[m[i*k+1].key;m[(i+1)*k].key\big]">, тъй като се извършва върху еднакъв брой елементи.
