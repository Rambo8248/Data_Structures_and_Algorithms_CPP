# Searching Algorithms

Aлгоритъмът за търсене е алгоритъм за намиране на елемент със специфични свойства сред колекция от елементи.

Име | метод | необходимост
------- | ------- | -------
**Linear Search** *Последователно търсене* |  обхожда елемент по елемент | изходен елемент
*Последователно търсене в сортиран списък* |  обхожда елемент по елемент, до достигане на такъв с по-голям ключ | няма
*Последователно търсене с преподреждане* |  обхожда елемент по елемент и актоализира позицията на всеки търсен елемент | няма

### 1. Последователно търсене
Най-елементарният и очевиден алгоритъм за търсене е последователното търсене. Нека предположим, че елементите на множеството се съдържат в едномерен масив. Търсенето се извършва посредством последователно преглеждане на елементите на масива до откриване на търсения елемент или до преглеждане на всички елементи. Последното означава, че елемент с такъв ключ не съществува.При постъпване на нов елемент ще го вмъкваме в края на масива *seqSearch()*. Следва една възможна реализация на основните функции, основаваща се на последователното търсене:

```cpp
#define MAX 10
#define DataType int
#include <iostream>
#include <time.h>

struct CPPElem
{
	int key;
	DataType data;
	/*...*/
}m[MAX + 1]; /* Масив от записи*/
unsigned n;  /*Брой елементи в масива*/

void seqInit(void) { n = 0; }  /*Инициализиране*/

unsigned seqSearch(int key)    /*Последователно търсене*/
{
	unsigned x;
	m[0].key = key;  /*Ограничител*/
	for (x = n + 1; key != m[--x].key; );
	return x;
}

void seqInsert(int key, DataType data) /*Добавя нов елемент*/
{
	m[++n].key = key;
	m[n].data = data;
}

void seqPrint(void) /*Извежда списъка на екрана*/
{
	unsigned i;

	for (i = 1; i <= n; i++)
	{
		std::cout << m[i].key << ' ' << m[i].data << std::endl;
	}
}

void performSearchTest(void)
{
	unsigned ind, elem2Search;
	for (elem2Search = 0; elem2Search < 2 * MAX; elem2Search++)
	{
		std::cout << "We search an element with key " << elem2Search << "\n";
		if (0 == (ind = seqSearch(elem2Search)))
			std::cout << "Element with such key does not exist!" << "\n\n";
		else
			std::cout << "Item found! Info part: " << m[ind].data << "\n\n";
	}
}

int main()
{
	srand(unsigned(time(0)));
	unsigned ind;
	seqInit();
	for (ind = 0; ind < MAX; ind++) seqInsert(rand() % (MAX * 2), ind);
	std::cout << "the list contains the following items:\n";
	seqPrint();
	std::cout << "Testing:\n";
	performSearchTest();
	return 0;
}
```
По-горе сме приели, че същинската информационна част на елементите на масива съдържа единствено поле *data*. Както се забелязва, търсенето се извършва последователно по посока на намаляване на индексите. Забележете, че нулевия елемент на масива не съдържа елемент на множеството, а служебна информация. Той е използван като *елемент-ограничител*, позволяващ опростяване на цикъла: проверява се само едно условие, тъй като сме осигурили намирането на елемент със зададения ключ (в краен случай нулевият). В случай на дублиране на ключове горният алгоритъм очевидно връща последния постъпил елемент с този ключ. 

Каква е сложността на алгоритъма в средния и в най-лошия случай съответно? Ясно е, че най-лошият случай е когато търсеният елемент липсва. Тогава се преглеждат всичките *n+1* елемента на масива, включително нулевият. В общия случай, когато търсенето е успешно, средният брой на извършените сравнения е <img src="https://latex.codecogs.com/svg.latex?\Large&space;\frac{n+1}{2}">. Същевременно, за намиране на всички елементи с даден ключ е необходимо *цялостно* преглеждане на масива.

#### 1.1. Последователно търсене в сортиран списък:

Последователното търсене, разгледано по-горе, е най-простият и най-неефективният алгоритъм за търсене. Бихме могли да се опитаме да подобрим ефективността му, поддържайки елементите в сортиран вид. Това ще ни се удаде сравнително лесно, ако използваме свързан списък вместо масив. Всичко което трябва да направим, е да вмъкваме всеки новопостъпил елемент на съответното му място, така че списъкът да остава сортиран. Така преди всяко вмъкване ще се изисква извършване на съответно търсене, за да се открие съответната позиция.

Операцията по вмъкване се усложнява значително. По-горе я извършвахме за константно време, без нито едно сравнение, а сега това ще изисква предварително търсене. Какво все пак постигнахме? Обстоятелството, че елементите са подредени в нарастващ ред, ще ни позволи да прекратяваме по-нанатъшното търсене при достигане на елемент с ключ, по-голям от търсения. Броят на необходимите сравнения в случай на неуспешно търсене намалява до <img src="https://latex.codecogs.com/svg.latex?\Large&space;\frac{n+1}{2}">, в сравнение с <img src="https://latex.codecogs.com/svg.latex?\Large&space;n+1"> при несортирания случай. На практика успешното и неуспешното търсене се оказват равнопоставени, тъй като тази модификация очевидно не влияе на успешното търсене. В най-лошия случай отново трябва да се прегледат всички елементи, т.е. да се извършат <img src="https://latex.codecogs.com/svg.latex?\Large&space;n+1"> сравнения. Оказва се, че в замяна на това, че сме приравнили сложността на вмъкването, която по-рано беше константна, към сложността на търсенето, получаваме само равнопоставеност на успешно и неуспешно търсене. Полученият реултат е изключително поучителен и показва, че преди да се пристъпи към някаква „очевидна“ оптимизация, следва много внимателно да се прецени възможната полза и вреда, които тя ще принесе.

Следва примерна реализация на последователно търсене в сортиран списък, заедно със съответна версия на функции за вмъкване и инициализиране:

```cpp
#define DataType int
#define MAX 10
#include <iostream>
#include <time.h>

struct CPPElem
{
	int key;
	DataType data;
	struct CPPElem *next;
	/* ... */
} *head;

void listInit(void) /* Инициализиране */
{
	head = (struct CPPElem*) malloc(sizeof *head);
	head->next = nullptr;
}

void listInsert(int key, DataType data)/* Добавя нов елемент */
{
	struct CPPElem *p, *q, *r;
	q = (struct CPPElem*) malloc(sizeof *head);
	r = (p = head)->next;
	while (r != nullptr && r->key < key)
	{
		p = r;
		r = r->next;
	}
	q->key = key;
	q->data = data;
	q->next = r;
	p->next = q;
}
struct CPPElem *listSearch(int key) /* Последователно търсене */
{
	struct CPPElem *q;
	for (q = head->next; q != nullptr&&q->key < key; q = q->next);
	if (nullptr == q || key != q->key)
		return nullptr;
	else
		return q;

}

void listPrint(void) /* Извежда списъка на екрана */
{
	struct CPPElem *q;
	for (q = head->next; q != nullptr; q = q->next)
	{
		std::cout << q->key << ' ' << q->data;
		std::cout << std::endl;
	}
}

int main()
{
	srand(unsigned(time(0)));
	unsigned ind;
	listInit();
	for (ind = 0; ind < MAX; ind++) listInsert(rand() % (MAX * 2), ind);
	std::cout << "the list contains the following items:\n";
	listPrint();

	std::cout << "Serching: \n";
	CPPElem *el = listSearch(8);
	if (el) std::cout <<"Element found: "<< el->data << ' ' << el->key<<'\n';	
	else std::cout << "No element with such key found.\n";
	
	return 0;
}
```
#### 1.1. Последователно търсене с преподреждане:

В случай, че разполагаме с предварителна информация относно вероятността за достъп до всеки от елементите, бихме могли да ги подредим така, че най-често търсеният да бъде на върха на списъка, следващият - непосредствено след него и т.н. Използването на подобна стратегия се оказва изключително ефективно, особено при силно неравномерно разпределение, при което малък брой елементи се търсят с много голяма ефективност.

В случай, че не разполагаме с такава предварителна информация, бихме могли сами да си я получим с помощта на прости статистически наблюдения: достатъчно е към всеки елемент да прикрепим брояч на достъпа до него. При всяко ново търсене ще актуализираме брояча на търсения елемент. Ясно е, че след актуализацията той евентуално ще може да мине по-напред в списъка. Ето защо следва да се направи сравнение с предходния елемент в списъка, при което евентуално двата да се разменят. Тъй като в списъка може да има многократно дублиране на честотите на достъп, в случай на размяна се налага съответно сравнение и със следващия предходен елемент и т.н. до достигане на точната позиция, съответваща на новата честота на елемента. Реорганизацията става за време, пропорционално на <img src="https://latex.codecogs.com/svg.latex?\Large&space;n">, като в най-лошия случай може да се случи последният елемент на списъка да стане първи, разменяйки се последователно с всички преди него [*Уирт-1980*].
